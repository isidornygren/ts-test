import * as fs from 'fs';
import * as path from 'path';
import * as tsNode from 'ts-node';

const rootDir = '/home/isidor/Projects/ts-test/src/__tests__';
const files = fs.readdirSync(rootDir).map(p => path.join(rootDir, p));

type Path = Array<Path> | string;

function fetchFiles(currentPath: Readonly<string>): Path | string {
    const stats = fs.lstatSync(currentPath);

    if(stats.isDirectory()) {
        const currentFiles = fs.readdirSync(currentPath).map(p => path.join(currentPath, p));
        return currentFiles.map(fetchFiles);
    }
    return currentPath;
}

const availableFiles = files.map(fetchFiles).flat(3) as Array<string>;

const failedModules: Array<{ fileName: string, funcName?: string, error: any }> = [];
const successfullModules: Array<{ fileName: string }> = [];

console.time('Time')


// tsNode.register({ options: { require: availableFiles } })

// files.forEach(file => {
// });

Promise.all(availableFiles.map(async fileName => {
    return import(fileName).then(importedModule => {
        const moduleFuncExports = Object.entries(importedModule).filter(
            ([key, value]) => typeof value === 'function'
        );

        // Should probably filter the exports here


        moduleFuncExports.forEach(([funcName, _func]) => {
            console.log('Running', funcName);
            try {
                importedModule[funcName]();
                successfullModules.push({ fileName })
            } catch(error) {
                console.log(error);
                failedModules.push({ fileName, funcName, error });
            }
        });
    }, error => {
        console.log(error);
        failedModules.push({
            fileName,
            error
        })
    });
})).then(() => {
    console.log('Finished running');
    const failed = failedModules.length > 0;
    const color = failed ? '\x1b[31m' : '\x1b[32m';
    console.log('Test files passed:', `${color}${successfullModules.length}/${successfullModules.length + failedModules.length}\x1b[0m`);
    console.timeEnd('Time')
    if(failed) {
        process.exit(1);
    }
}, () => {});

// Typescript easy satisfactory testing